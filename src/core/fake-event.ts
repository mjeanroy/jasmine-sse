/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018 Mickael Jeanroy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

import {factory} from './common/factory';
import {NONE, CAPTURING_PHASE, BUBBLING_PHASE, AT_TARGET} from './event-states';

/**
 * The `FakeEvent` interface.
 */
export interface FakeEvent extends Event {
  _stopped: boolean;
  _eventPhase: number;
}

export const fakeEventFactory = factory(() => {
  /**
   * A fake implementation of `Event`.
   *
   * @class
   */
  return class FakeEventImpl implements FakeEvent {
    private _type: string;
    private _cancelable: boolean;
    private _defaultPrevented: boolean;
    private _bubbles: boolean;
    private _isTrusted: boolean;
    private _composed: boolean;
    private _timeStamp: number;

    _eventPhase: number;
    _stopped: boolean;

    private _target: EventTarget;
    private _currentTarget: EventTarget;
    private _srcElement: EventTarget;
    private _composedPath: EventTarget;

    returnValue: boolean;
    cancelBubble: boolean;

    /**
     * Create the fake `Event` class.
     *
     * @param {string} type The event type.
     * @param {*} target The event target.
     * @constructor
     */
    constructor(type: string, target: EventTarget) {
      this._type = type;
      this._eventPhase = NONE;
      this._cancelable = false;
      this._defaultPrevented = false;
      this._bubbles = false;
      this._isTrusted = true;
      this._composed = false;
      this._timeStamp = new Date().getTime();
      this._stopped = false;

      this._target = target;
      this._currentTarget = target;
      this._srcElement = target;
      this._composedPath = target;

      // Non readonly properties.
      this.returnValue = true;
      this.cancelBubble = false;
    }

    /**
     * The name of the event (case-insensitive).
     *
     * @return {string} The event type.
     */
    get type(): string {
      return this._type;
    }

    /**
     * Indicates which phase of the event flow is currently being evaluated.
     *
     * @return {number} An integer value which specifies the current evaluation phase.
     */
    get eventPhase(): number {
      return this._eventPhase;
    }

    /**
     * A Boolean indicating whether the event is cancelable.
     *
     * @return {boolean} The `cancelable` flag.
     */
    get cancelable(): boolean {
      return this._cancelable;
    }

    /**
     * Indicates whether or not event.preventDefault() has been called on the event.
     *
     * @return {boolean} `true` if `preventDefault` has been called, `false` otherwise.
     */
    get defaultPrevented(): boolean {
      return this._defaultPrevented;
    }

    /**
     * A Boolean indicating whether the event bubbles up through the DOM or not.
     *
     * @return {boolean} The `bubbles` flag.
     */
    get bubbles(): boolean {
      return this._bubbles;
    }

    /**
     * A Boolean value indicating whether or not the event can bubble across the
     * boundary between the shadow DOM and the regular DOM.
     *
     * @return {boolean} The `composed` flag.
     */
    get composed(): boolean {
      return this._composed;
    }

    get composedPath(): any {
      return this._composedPath;
    }

    /**
     * The time at which the event was created (in milliseconds)
     *  By specification, this value is time since epoch.
     *
     * @return {number} The timestamp of event creation.
     */
    get timeStamp(): number {
      return this._timeStamp;
    }

    /**
     * The isTrusted read-only property of the Event interface is a boolean that is true
     * when the event was generated by a user action, and false when the event was
     * created or modified by a script or dispatched via dispatchEvent.
     *
     * @return {boolean} The `isTrusted` flag.
     */
    get isTrusted(): boolean {
      return this._isTrusted;
    }

    /**
     * A reference to the currently registered target for the event.
     * This is the object to which the event is currently slated to be sent; it's possible
     * this has been changed along the way through retargeting.
     *
     * @return {Object} The event target.
     */
    get currentTarget(): any {
      return this._currentTarget;
    }

    /**
     * A reference to the target to which the event was originally dispatched.
     *
     * @return {Object} The event target.
     */
    get target(): any {
      return this._target;
    }

    /**
     * The non-standard alias (from old versions of Microsoft Internet Explorer) for Event.target,
     * which is starting to be supported in some other browsers for web compatibility purposes.
     *
     * @return {Object} The event target.
     */
    get srcElement(): any {
      return this._srcElement;
    }

    /**
     * Initializes the value of an Event created. If the event has already being
     * dispatched, this method does nothing.
     *
     * @return {void}
     */
    initEvent(): void {
    }

    /**
     * Cancels the event (if it is cancelable).
     *
     * @return {void}
     */
    preventDefault(): void {
      if (this._cancelable) {
        this._defaultPrevented = true;
      }
    }

    /**
     * For this particular event, no other listener will be called.
     * Neither those attached on the same element, nor those attached on elements
     * which will be traversed later (in capture phase, for instance).
     *
     * @return {void}
     */
    stopImmediatePropagation(): void {
      this.cancelBubble = true;
      this._stopped = true;
    }

    /**
     * Stops the propagation of events further along in the DOM.
     *
     * @return {void}
     */
    stopPropagation(): void {
      this.cancelBubble = true;
    }

    get NONE(): number {
      return NONE;
    }

    get BUBBLING_PHASE(): number {
      return BUBBLING_PHASE;
    }

    get CAPTURING_PHASE(): number {
      return CAPTURING_PHASE;
    }

    get AT_TARGET(): number {
      return AT_TARGET;
    }
  }
});
